{"ast":null,"code":"import { resolveLocale as resolveLocaleForData } from './LocaleDataStore.js';\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * @param  {string} locale\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocale(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocale(\"xx-Latn\")\r\n */\n\nexport default function resolveLocale(locale) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var localeMatcher = options.localeMatcher || 'lookup';\n  switch (localeMatcher) {\n    case 'lookup':\n      return resolveLocaleLookup(locale);\n    // \"best fit\" locale matching is not supported.\n    // https://github.com/catamphetamine/relative-time-format/issues/2\n\n    case 'best fit':\n      // return resolveLocaleBestFit(locale)\n      return resolveLocaleLookup(locale);\n    default:\n      throw new RangeError(\"Invalid \\\"localeMatcher\\\" option: \".concat(localeMatcher));\n  }\n}\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * Starts from the most specific locale and gradually\r\n * falls back to less specific ones.\r\n * This is a basic implementation of the \"lookup\" algorithm.\r\n * https://tools.ietf.org/html/rfc4647#section-3.4\r\n * @param  {string} locale\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocaleLookup(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocaleLookup(\"xx-Latn\")\r\n */\n\nexport function resolveLocaleLookup(locale) {\n  var resolvedLocale = resolveLocaleForData(locale);\n  if (resolvedLocale) {\n    return resolvedLocale;\n  } // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\n\n  var parts = locale.split('-');\n  while (locale.length > 1) {\n    parts.pop();\n    locale = parts.join('-');\n    var _resolvedLocale = resolveLocaleForData(locale);\n    if (_resolvedLocale) {\n      return _resolvedLocale;\n    }\n  }\n}","map":{"version":3,"sources":["../source/resolveLocale.js"],"names":["resolveLocale","resolveLocaleForData","locale","options","localeMatcher","resolveLocaleLookup","RangeError","resolvedLocale","parts","split","length","pop","join"],"mappings":"AAAA,SACEA,aAAa,IAAIC,oBADnB,QAEO,sBAFP;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASD,aAAT,CAAuBE,MAAvB,EAA6C;EAAA,IAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;EAC1D,IAAMC,aAAa,GAAGD,OAAO,CAACC,aAARD,IAAyB,QAA/C;EACA,QAAQC,aAAR;IACE,KAAK,QAAL;MACE,OAAOC,mBAAmB,CAACH,MAAD,CAA1B;IACF;IACA;;IACA,KAAK,UAAL;MACE;MACA,OAAOG,mBAAmB,CAACH,MAAD,CAA1B;IACF;MACE,MAAM,IAAII,UAAJ,CAAA,oCAAA,CAAA,MAAA,CAAkDF,aAAlD,CAAA,CAAN;EAAA;AAEL;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,mBAAT,CAA6BH,MAA7B,EAAqC;EAC1C,IAAMK,cAAc,GAAGN,oBAAoB,CAACC,MAAD,CAA3C;EACA,IAAIK,cAAJ,EAAoB;IAClB,OAAOA,cAAP;EACD,CAJyC,CAK1C;;EACA,IAAMC,KAAK,GAAGN,MAAM,CAACO,KAAPP,CAAa,GAAbA,CAAd;EACA,OAAOA,MAAM,CAACQ,MAAPR,GAAgB,CAAvB,EAA0B;IACxBM,KAAK,CAACG,GAANH,EAAAA;IACAN,MAAM,GAAGM,KAAK,CAACI,IAANJ,CAAW,GAAXA,CAATN;IACA,IAAMK,eAAc,GAAGN,oBAAoB,CAACC,MAAD,CAA3C;IACA,IAAIK,eAAJ,EAAoB;MAClB,OAAOA,eAAP;IACD;EACF;AACF","sourcesContent":["import {\r\n  resolveLocale as resolveLocaleForData\r\n} from './LocaleDataStore.js'\r\n\r\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * @param  {string} locale\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocale(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocale(\"xx-Latn\")\r\n */\r\nexport default function resolveLocale(locale, options = {}) {\r\n  const localeMatcher = options.localeMatcher || 'lookup'\r\n  switch (localeMatcher) {\r\n    case 'lookup':\r\n      return resolveLocaleLookup(locale)\r\n    // \"best fit\" locale matching is not supported.\r\n    // https://github.com/catamphetamine/relative-time-format/issues/2\r\n    case 'best fit':\r\n      // return resolveLocaleBestFit(locale)\r\n      return resolveLocaleLookup(locale)\r\n    default:\r\n      throw new RangeError(`Invalid \"localeMatcher\" option: ${localeMatcher}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * Starts from the most specific locale and gradually\r\n * falls back to less specific ones.\r\n * This is a basic implementation of the \"lookup\" algorithm.\r\n * https://tools.ietf.org/html/rfc4647#section-3.4\r\n * @param  {string} locale\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocaleLookup(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocaleLookup(\"xx-Latn\")\r\n */\r\nexport function resolveLocaleLookup(locale) {\r\n  const resolvedLocale = resolveLocaleForData(locale)\r\n  if (resolvedLocale) {\r\n    return resolvedLocale\r\n  }\r\n  // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\r\n  const parts = locale.split('-')\r\n  while (locale.length > 1) {\r\n    parts.pop()\r\n    locale = parts.join('-')\r\n    const resolvedLocale = resolveLocaleForData(locale)\r\n    if (resolvedLocale) {\r\n      return resolvedLocale\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}