function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component, Fragment } from 'react';
import PropTypes from 'prop-types';
import Image from './components/Image';
import ZoomImage from './components/ZoomImage';
import FullscreenPortal from './components/FullscreenPortal';

var InnerImageZoom = function (_Component) {
  _inherits(InnerImageZoom, _Component);

  function InnerImageZoom(props) {
    _classCallCheck(this, InnerImageZoom);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.handleMouseEnter = function (e) {
      _this.setState({
        isActive: true
      });

      if (_this.props.zoomType === 'hover' && !_this.state.isZoomed) {
        _this.handleClick(e);
      }
    };

    _this.handleTouchStart = function () {
      var isFullscreen = _this.props.fullscreenOnMobile && window.matchMedia && window.matchMedia('(max-width: ' + _this.props.mobileBreakpoint + 'px)').matches;

      _this.setState({
        isTouch: true,
        isFullscreen: isFullscreen,
        currentMoveType: 'drag'
      });
    };

    _this.handleClick = function (e) {
      if (_this.state.isZoomed) {
        if (!_this.state.isTouch && !_this.state.isDragging) {
          _this.zoomOut();
        }

        return;
      }

      if (_this.state.isTouch) {
        _this.setState({
          isActive: true
        });
      }

      if (_this.isLoaded) {
        _this.zoomIn(e.pageX, e.pageY);
      } else {
        _this.onLoadCallback = _this.zoomIn.bind(_this, e.pageX, e.pageY);
      }
    };

    _this.handleLoad = function (e) {
      _this.isLoaded = true;
      _this.zoomImg = e.target;
      _this.zoomImg.setAttribute('width', _this.zoomImg.offsetWidth * _this.props.zoomScale);
      _this.zoomImg.setAttribute('height', _this.zoomImg.offsetHeight * _this.props.zoomScale);
      _this.bounds = _this.getBounds(_this.img, false);
      _this.ratios = _this.getRatios(_this.bounds, _this.zoomImg);

      if (_this.onLoadCallback) {
        _this.onLoadCallback();
        _this.onLoadCallback = null;
      }
    };

    _this.handleMouseMove = function (e) {
      var left = e.pageX - _this.offsets.x;
      var top = e.pageY - _this.offsets.y;

      left = Math.max(Math.min(left, _this.bounds.width), 0);
      top = Math.max(Math.min(top, _this.bounds.height), 0);

      _this.setState({
        left: left * -_this.ratios.x,
        top: top * -_this.ratios.y
      });
    };

    _this.handleDragStart = function (e) {
      _this.offsets = _this.getOffsets(e.pageX || e.changedTouches[0].pageX, e.pageY || e.changedTouches[0].pageY, _this.zoomImg.offsetLeft, _this.zoomImg.offsetTop);
      _this.zoomImg.addEventListener(_this.state.isTouch ? 'touchmove' : 'mousemove', _this.handleDragMove, { passive: false });

      if (!_this.state.isTouch) {
        _this.eventPosition = {
          x: e.pageX,
          y: e.pageY
        };
      }
    };

    _this.handleDragMove = function (e) {
      e.preventDefault();
      e.stopPropagation();

      var left = (e.pageX || e.changedTouches[0].pageX) - _this.offsets.x;
      var top = (e.pageY || e.changedTouches[0].pageY) - _this.offsets.y;

      left = Math.max(Math.min(left, 0), (_this.zoomImg.offsetWidth - _this.bounds.width) * -1);
      top = Math.max(Math.min(top, 0), (_this.zoomImg.offsetHeight - _this.bounds.height) * -1);

      _this.setState({
        left: left,
        top: top
      });
    };

    _this.handleDragEnd = function (e) {
      _this.zoomImg.removeEventListener(_this.state.isTouch ? 'touchmove' : 'mousemove', _this.handleDragMove);

      if (!_this.state.isTouch) {
        var moveX = Math.abs(e.pageX - _this.eventPosition.x);
        var moveY = Math.abs(e.pageY - _this.eventPosition.y);

        _this.setState({
          isDragging: moveX > 5 || moveY > 5
        });
      }
    };

    _this.handleMouseLeave = function (e) {
      _this.state.currentMoveType === 'drag' && _this.state.isZoomed ? _this.handleDragEnd(e) : _this.handleClose();
    };

    _this.handleClose = function () {
      _this.zoomOut(function () {
        setTimeout(function () {
          _this.setDefaults();

          _this.setState({
            isActive: false,
            isTouch: false,
            isFullscreen: false,
            currentMoveType: _this.props.moveType
          });
        }, _this.props.fadeDuration);
      });
    };

    _this.initialMove = function (pageX, pageY) {
      _this.offsets = _this.getOffsets(window.pageXOffset, window.pageYOffset, -_this.bounds.left, -_this.bounds.top);

      _this.handleMouseMove({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.initialDragMove = function (pageX, pageY) {
      var initialPageX = (pageX - (window.pageXOffset + _this.bounds.left)) * -_this.ratios.x;
      var initialPageY = (pageY - (window.pageYOffset + _this.bounds.top)) * -_this.ratios.y;

      _this.bounds = _this.getBounds(_this.img, _this.state.isFullscreen);
      _this.offsets = _this.getOffsets(0, 0, 0, 0);

      _this.handleDragMove({
        changedTouches: [{
          pageX: initialPageX,
          pageY: initialPageY
        }],
        preventDefault: function preventDefault() {},
        stopPropagation: function stopPropagation() {}
      });
    };

    _this.zoomIn = function (pageX, pageY) {
      _this.setState({
        isZoomed: true
      }, function () {
        var initialMove = _this.state.currentMoveType === 'drag' ? _this.initialDragMove : _this.initialMove;
        initialMove(pageX, pageY);

        if (_this.props.afterZoomIn) {
          _this.props.afterZoomIn();
        }
      });
    };

    _this.zoomOut = function (callback) {
      _this.setState({
        isZoomed: false
      }, function () {
        if (_this.props.afterZoomOut) {
          _this.props.afterZoomOut();
        }

        if (callback) {
          callback();
        }
      });
    };

    _this.setDefaults = function () {
      _this.isLoaded = false;
      _this.onLoadCallback = null;
      _this.zoomImg = null;
      _this.bounds = {};
      _this.offsets = {};
      _this.ratios = {};
      _this.eventPosition = {};
    };

    _this.getBounds = function (img, isFullscreen) {
      if (isFullscreen) {
        return {
          width: window.innerWidth,
          height: window.innerHeight,
          left: 0,
          top: 0
        };
      }

      return img.getBoundingClientRect();
    };

    _this.getOffsets = function (pageX, pageY, left, top) {
      return {
        x: pageX - left,
        y: pageY - top
      };
    };

    _this.getRatios = function (bounds, zoomImg) {
      return {
        x: (zoomImg.offsetWidth - bounds.width) / bounds.width,
        y: (zoomImg.offsetHeight - bounds.height) / bounds.height
      };
    };

    _this.state = {
      isActive: props.startsActive === true ? true : false,
      isTouch: false,
      isZoomed: false,
      isFullscreen: false,
      isDragging: false,
      currentMoveType: props.moveType,
      left: 0,
      top: 0
    };

    _this.setDefaults();
    return _this;
  }

  InnerImageZoom.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        src = _props.src,
        srcSet = _props.srcSet,
        sizes = _props.sizes,
        sources = _props.sources,
        zoomSrc = _props.zoomSrc,
        alt = _props.alt,
        fadeDuration = _props.fadeDuration,
        className = _props.className;


    var zoomImageProps = {
      src: zoomSrc || src,
      fadeDuration: this.state.isFullscreen ? 0 : fadeDuration,
      top: this.state.top,
      left: this.state.left,
      isZoomed: this.state.isZoomed,
      onLoad: this.handleLoad,
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onClose: this.state.isTouch ? this.handleClose : null
    };

    return React.createElement(
      'figure',
      {
        className: 'iiz ' + (this.state.currentMoveType === 'drag' ? 'iiz--drag' : '') + ' ' + (className ? className : ''),
        ref: function ref(el) {
          _this2.img = el;
        },
        onTouchStart: this.handleTouchStart,
        onClick: this.handleClick,
        onMouseEnter: this.state.isTouch ? null : this.handleMouseEnter,
        onMouseMove: this.state.currentMoveType === 'drag' || !this.state.isZoomed ? null : this.handleMouseMove,
        onMouseLeave: this.state.isTouch ? null : this.handleMouseLeave
      },
      React.createElement(Image, {
        src: src,
        srcSet: srcSet,
        sizes: sizes,
        sources: sources,
        alt: alt,
        fadeDuration: this.props.fadeDuration,
        isZoomed: this.state.isZoomed
      }),
      this.state.isActive && React.createElement(
        Fragment,
        null,
        this.state.isFullscreen ? React.createElement(
          FullscreenPortal,
          { className: 'iiz__zoom-portal' },
          React.createElement(ZoomImage, zoomImageProps)
        ) : React.createElement(ZoomImage, zoomImageProps)
      ),
      !this.state.isZoomed && React.createElement('span', { className: 'iiz__btn iiz__hint' })
    );
  };

  return InnerImageZoom;
}(Component);

InnerImageZoom.propTypes = process.env.NODE_ENV !== "production" ? {
  moveType: PropTypes.string,
  zoomType: PropTypes.string,
  src: PropTypes.string.isRequired,
  srcSet: PropTypes.string,
  sizes: PropTypes.string,
  sources: PropTypes.array,
  zoomSrc: PropTypes.string,
  zoomScale: PropTypes.number,
  alt: PropTypes.string,
  fadeDuration: PropTypes.number,
  fullscreenOnMobile: PropTypes.bool,
  mobileBreakpoint: PropTypes.number,
  className: PropTypes.string,
  afterZoomIn: PropTypes.func,
  afterZoomOut: PropTypes.func,
  startsActive: PropTypes.bool
} : {};

InnerImageZoom.defaultProps = {
  moveType: 'pan',
  zoomType: 'click',
  zoomScale: 1,
  fadeDuration: 150,
  mobileBreakpoint: 640
};

export default InnerImageZoom;