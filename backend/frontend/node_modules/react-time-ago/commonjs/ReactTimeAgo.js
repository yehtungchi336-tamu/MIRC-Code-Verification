'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _javascriptTimeAgo = require('javascript-time-ago');

var _javascriptTimeAgo2 = _interopRequireDefault(_javascriptTimeAgo);

var _verboseDateFormatter = require('./helpers/verboseDateFormatter');

var _verboseDateFormatter2 = _interopRequireDefault(_verboseDateFormatter);

var _date = require('./helpers/date');

var _Updater = require('./Updater');

var _Updater2 = _interopRequireDefault(_Updater);

var _PropTypes = require('./PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ReactTimeAgo(_ref) {
	var date = _ref.date,
	    future = _ref.future,
	    timeStyle = _ref.timeStyle,
	    round = _ref.round,
	    minTimeLeft = _ref.minTimeLeft,
	    tooltip = _ref.tooltip,
	    Component = _ref.component,
	    container = _ref.container,
	    wrapperComponent = _ref.wrapperComponent,
	    wrapperProps = _ref.wrapperProps,
	    locale = _ref.locale,
	    locales = _ref.locales,
	    formatVerboseDate = _ref.formatVerboseDate,
	    verboseDateFormat = _ref.verboseDateFormat,
	    updateInterval = _ref.updateInterval,
	    tick = _ref.tick,
	    rest = _objectWithoutProperties(_ref, ['date', 'future', 'timeStyle', 'round', 'minTimeLeft', 'tooltip', 'component', 'container', 'wrapperComponent', 'wrapperProps', 'locale', 'locales', 'formatVerboseDate', 'verboseDateFormat', 'updateInterval', 'tick']);

	// Get the list of preferred locales.
	var preferredLocales = (0, _react.useMemo)(function () {
		// Convert `locale` to `locales`.
		if (locale) {
			locales = [locale];
		}
		// Add `javascript-time-ago` default locale.
		return locales.concat(_javascriptTimeAgo2.default.getDefaultLocale());
	}, [locale, locales]);

	// Create `javascript-time-ago` formatter instance.
	var timeAgo = (0, _react.useMemo)(function () {
		return new _javascriptTimeAgo2.default(preferredLocales);
	}, [preferredLocales]);

	// The date or timestamp that was passed.
	// Convert timestamp to `Date`.
	date = (0, _react.useMemo)(function () {
		return (0, _date.getDate)(date);
	}, [date]);

	// Formats the `date`.
	var formatDate = (0, _react.useCallback)(function () {
		var now = Date.now();
		var stopUpdates = void 0;
		if (future) {
			if (now >= date.getTime()) {
				now = date.getTime();
				stopUpdates = true;
			}
		}
		if (minTimeLeft !== undefined) {
			var maxNow = date.getTime() - minTimeLeft * 1000;
			if (now > maxNow) {
				now = maxNow;
				stopUpdates = true;
			}
		}

		var _timeAgo$format = timeAgo.format(date, timeStyle, {
			getTimeToNextUpdate: true,
			now: now,
			future: future,
			round: round
		}),
		    _timeAgo$format2 = _slicedToArray(_timeAgo$format, 2),
		    formattedDate = _timeAgo$format2[0],
		    timeToNextUpdate = _timeAgo$format2[1];

		if (stopUpdates) {
			timeToNextUpdate = INFINITY;
		} else {
			// Legacy compatibility: there used to be an `updateInterval` property.
			// That was before `getTimeToNextUpdate` feature was introduced in `javascript-time-ago`.
			// A default interval of one minute is introduced because
			// `getTimeToNextUpdate` feature may theoretically return `undefined`.
			timeToNextUpdate = updateInterval || timeToNextUpdate || 60 * 1000; // A minute by default.
		}
		return [formattedDate, now + timeToNextUpdate];
	}, [date, future, timeStyle, updateInterval, round, minTimeLeft, timeAgo]);

	var formatDateRef = (0, _react.useRef)();
	formatDateRef.current = formatDate;

	var _useMemo = (0, _react.useMemo)(formatDate, []),
	    _useMemo2 = _slicedToArray(_useMemo, 2),
	    _formattedDate = _useMemo2[0],
	    _nextUpdateTime = _useMemo2[1];

	var _useState = (0, _react.useState)(_formattedDate),
	    _useState2 = _slicedToArray(_useState, 2),
	    formattedDate = _useState2[0],
	    setFormattedDate = _useState2[1];

	// The component sets the "verbose date" tooltip after the component 
	// has mounted rather than on the first render. 
	// The reason is that otherwise React would complain that 
	// server-side-rendered markup doesn't match client-side-rendered one.


	var _useState3 = (0, _react.useState)(),
	    _useState4 = _slicedToArray(_useState3, 2),
	    shouldSetTooltipText = _useState4[0],
	    setShouldSetTooltipText = _useState4[1];

	var updater = (0, _react.useRef)();

	(0, _react.useEffect)(function () {
		if (tick) {
			updater.current = _Updater2.default.add({
				getNextValue: function getNextValue() {
					return formatDateRef.current();
				},
				setValue: setFormattedDate,
				nextUpdateTime: _nextUpdateTime
			});
			return function () {
				return updater.current.stop();
			};
		}
	}, [tick]);

	(0, _react.useEffect)(function () {
		if (updater.current) {
			updater.current.forceUpdate();
		} else {
			var _formatDate = formatDate(),
			    _formatDate2 = _slicedToArray(_formatDate, 1),
			    _formattedDate2 = _formatDate2[0];

			setFormattedDate(_formattedDate2);
		}
	}, [formatDate]);

	(0, _react.useEffect)(function () {
		setShouldSetTooltipText(true);
	}, []);

	// Create verbose date formatter for the tooltip text.
	// (only on client side, because tooltips aren't rendered 
	//  until triggered by user interaction)
	var verboseDateFormatter = (0, _react.useMemo)(function () {
		if (typeof window !== 'undefined') {
			return (0, _verboseDateFormatter2.default)(preferredLocales, verboseDateFormat);
		}
	}, [preferredLocales, verboseDateFormat]);

	// Format verbose date for the tooltip.
	// (only on client side, because tooltips aren't rendered 
	//  until triggered by user interaction)
	var verboseDate = (0, _react.useMemo)(function () {
		if (typeof window !== 'undefined') {
			if (formatVerboseDate) {
				return formatVerboseDate(date);
			}
			return verboseDateFormatter(date);
		}
	}, [date, formatVerboseDate, verboseDateFormatter]);

	var result = _react2.default.createElement(
		Component,
		_extends({
			date: date,
			verboseDate: shouldSetTooltipText ? verboseDate : undefined,
			tooltip: tooltip
		}, rest),
		formattedDate
	);

	var WrapperComponent = wrapperComponent || container;

	if (WrapperComponent) {
		return _react2.default.createElement(
			WrapperComponent,
			_extends({}, wrapperProps, {
				verboseDate: shouldSetTooltipText ? verboseDate : undefined }),
			result
		);
	}

	return result;
}

ReactTimeAgo.propTypes = {
	// The `date` or `timestamp`.
	// E.g. `new Date()` or `1355972400000`.
	date: _propTypes2.default.oneOfType([_propTypes2.default.instanceOf(Date), _propTypes2.default.number]).isRequired,

	// Preferred locale.
	// Is 'en' by default.
	// E.g. 'ru-RU'.
	locale: _propTypes2.default.string,

	// Alternatively to `locale`, one could pass `locales`:
	// A list of preferred locales (ordered).
	// Will choose the first supported locale from the list.
	// E.g. `['ru-RU', 'en-GB']`.
	locales: _propTypes2.default.arrayOf(_propTypes2.default.string),

	// If set to `true`, then will stop at "zero point"
	// when going from future dates to past dates.
	// In other words, even if the `date` has passed,
	// it will still render as if `date` is `now`.
	future: _propTypes2.default.bool,

	// Date/time formatting style.
	// See `javascript-time-ago` docs on "Styles" for more info.
	// E.g. 'round', 'round-minute', 'twitter', 'twitter-first-minute'.
	timeStyle: _PropTypes.style,

	// `round` parameter of `javascript-time-ago`.
	// See `javascript-time-ago` docs on "Rounding" for more info.
	// Examples: "round", "floor".
	round: _propTypes2.default.string,

	// If specified, the time won't "tick" past this threshold (in seconds).
	// For example, if `minTimeLeft` is `60 * 60`
	// then the time won't "tick" past "in 1 hour".
	minTimeLeft: _propTypes2.default.number,

	// A React component to render the relative time label.
	// Receives properties:
	// * date: Date — The date.
	// * verboseDate: string? — Formatted verbose date. Is always present on client, is always `undefined` on server (because tooltips aren't shown on server).
	// * tooltip: boolean — The `tooltip` property of `<ReactTimeAgo/>` component.
	// * children: string — The relative time label.
	// * All "unknown" properties that have been passed to `<ReactTimeAgo/>` are passed through to this component.
	component: _propTypes2.default.elementType.isRequired,

	// Whether to use HTML `tooltip` attribute to show a verbose date tooltip.
	// Is `true` by default.
	// Can be set to `false` to disable the native HTML `tooltip`.
	tooltip: _propTypes2.default.bool.isRequired,

	// Verbose date formatter.
	// By default it's `(date) => new Intl.DateTimeFormat(locale, {…}).format(date)`.
	formatVerboseDate: _propTypes2.default.func,

	// `Intl.DateTimeFormat` format for formatting verbose date.
	// See `Intl.DateTimeFormat` docs for more info.
	verboseDateFormat: _propTypes2.default.object,

	// (deprecated)
	// How often the component refreshes itself.
	// Instead, consider using `getNextTimeToUpdate()` feature
	// of `javascript-time-ago` styles.
	updateInterval: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.shape({
		threshold: _propTypes2.default.number,
		interval: _propTypes2.default.number.isRequired
	}))]),

	// (deprecated).
	// Set to `false` to disable automatic refresh of the component.
	// Is `true` by default.
	// I guess no one actually turns that off.
	tick: _propTypes2.default.bool,

	// (advanced)
	// A React Component to wrap the resulting `<time/>` React Element.
	// Receives `verboseDate` and `children` properties.
	// Also receives `wrapperProps`, if they're passed.
	// `verboseDate` can be used for displaying verbose date label
	// in an "on mouse over" (or "on touch") tooltip.
	// See the "Tooltip" readme section for more info.
	// Another example could be having `wrapperComponent`
	// being rerendered every time the component refreshes itself.
	wrapperComponent: _propTypes2.default.func,

	// Custom `props` passed to `wrapperComponent`.
	wrapperProps: _propTypes2.default.object
};

ReactTimeAgo.defaultProps = {
	// No preferred locales.
	locales: [],

	// Use a `<time/>` tag by default.
	component: Time,

	// Use HTML `tooltip` attribute to show a verbose date tooltip.
	tooltip: true,

	// `Intl.DateTimeFormat` for verbose date.
	// Example: "Thursday, December 20, 2012, 7:00:00 AM GMT+4"
	verboseDateFormat: {
		weekday: 'long',
		day: 'numeric',
		month: 'long',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit',
		second: '2-digit'
		// timeZoneName: 'short'
	},

	// Automatically refreshes itself.
	tick: true

	// The component schedules a next refresh every time it renders.
	// There's no need to rerender this component unless its props change.
};ReactTimeAgo = _react2.default.memo(ReactTimeAgo);

exports.default = ReactTimeAgo;

// `setTimeout()` has a bug where it fires immediately
// when the interval is longer than about `24.85` days.
// https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values

var SET_TIMEOUT_MAX_SAFE_INTERVAL = 2147483647;
function getSafeTimeoutInterval(interval) {
	return Math.min(interval, SET_TIMEOUT_MAX_SAFE_INTERVAL);
}

// A thousand years is practically a metaphor for "infinity".
var YEAR = 365 * 24 * 60 * 60 * 1000;
var INFINITY = 1000 * YEAR;

function Time(_ref2) {
	var date = _ref2.date,
	    verboseDate = _ref2.verboseDate,
	    tooltip = _ref2.tooltip,
	    children = _ref2.children,
	    rest = _objectWithoutProperties(_ref2, ['date', 'verboseDate', 'tooltip', 'children']);

	var isoString = (0, _react.useMemo)(function () {
		return date.toISOString();
	}, [date]);
	return _react2.default.createElement(
		'time',
		_extends({}, rest, {
			dateTime: isoString,
			title: tooltip ? verboseDate : undefined }),
		children
	);
}

Time.propTypes = {
	date: _propTypes2.default.instanceOf(Date).isRequired,
	verboseDate: _propTypes2.default.string,
	tooltip: _propTypes2.default.bool.isRequired,
	children: _propTypes2.default.string.isRequired
};
//# sourceMappingURL=ReactTimeAgo.js.map